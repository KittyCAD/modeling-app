/// Functions for sketch mode 2.0 (constraints version)

@no_std
@settings(defaultLengthUnit = mm, kclVersion = 1.0, experimentalFeatures = allow)

import Point2d, Segment from "std::types"

@(impl = std_rust_constrainable, experimental = true, feature_tree = false)
export fn point(
  at: Point2d,
): Segment {}

@(impl = std_rust_constrainable, experimental = true, feature_tree = false)
export fn line(
  start: Point2d,
  end?: Point2d,
  midpoint?: Point2d,
  construction?: bool,
): Segment {}

/// A circular arc. The arc segment always sweeps counterclockwise from start to end.
/// To change direction, swap the start and end points.
@(impl = std_rust_constrainable, experimental = true, feature_tree = false)
export fn arc(
  start: Point2d,
  end: Point2d,
  center: Point2d,
  construction?: bool,
): Segment {}

/// Constrain points, or a point and a segment to be coincident.
///
/// Supports two points, or one point and one segment (line/arc).
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn coincident(@points: [Segment; 2]) {}

/// Constrain the distance between two points.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn distance(@points: [Segment; 2]) {}

/// Constrain the radius of an arc segment.
/// Accepts a single arc segment and constrains the distance from its center to its start point.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn radius(@points: Segment) {}

/// Constrain the diameter of an arc or circle segment.
/// Accepts a single arc or circle segment and constrains the distance from its center to its start point.
/// Note: Diameter uses the same solver constraint as radius (distance between two points),
/// but is stored as a separate constraint type for proper UI display.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn diameter(@points: Segment) {}

/// Constrain the horizontal distance between two points.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn horizontalDistance(@points: [Segment; 2]) {}

/// Constrain the vertical distance between two points.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn verticalDistance(@points: [Segment; 2]) {}

/// Constrain lines to have equal length.
///
/// Currently limited to two lines.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn equalLength(@lines: [Segment; 2]) {}

/// Constrain lines to be parallel.
///
/// Currently limited to two lines.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn parallel(@input: [Segment; 2+]) {}

/// Constrain lines to be perpendicular.
///
/// Currently limited to two lines.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn perpendicular(@input: [Segment; 2+]) {}

/// Constrain lines to meet at a given angle.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn angle(@input: [Segment; 2]): number(Angle) {}

/// Constrain a line to be horizontal.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn horizontal(@input: Segment) {}

/// Constrain a line to be vertical.
@(impl = std_rust_constraint, experimental = true, feature_tree = true)
export fn vertical(@input: Segment) {}

/// Create a region from closed segments.
///
/// Form the region by tracing the first segment from its start point to the
/// intersection with the second segment, and turn at each intersection using
///  the `direction` until returning back to the first segment.
@(impl = std_rust, experimental = true, feature_tree = true)
export fn region(
  /// The first two segments that form the region's boundary.
  segments: [Segment; 2],
  /// Index of the intersection of the first segment with the second segment to
  /// use as the region's boundary. The default is `-1`, which uses the last
  /// intersection.
  intersectionIndex?: number(Count),
  /// `CCW` for counterclockwise, `CW` for clockwise. Default is `CCW`.
  direction?: string = "ccw",
) {}
