// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

/**
 * Add a hole to a closed path by offsetting it a uniform distance inward.
 */
export type AddHoleFromOffset = {
  /**
   * The closed path to add a hole to.
   */
  object_id: string
  /**
   * The distance to offset the path (positive for outset, negative for inset)
   */
  offset: LengthUnit
}

/**
 * An angle, with a specific unit.
 */
export type Angle = {
  /**
   * What unit is the measurement?
   */
  unit: UnitAngle
  /**
   * The size of the angle, measured in the chosen unit.
   */
  value: number
}

/**
 * Parameters for defining an MBD Basic Dimension Annotation state which is measured between two positions in 3D
 */
export type AnnotationBasicDimension = {
  /**
   * Entity to measure the dimension from
   */
  from_entity_id: string
  /**
   * Normalized position within the entity to position the dimension from
   */
  from_entity_pos: Point2d<number>
  /**
   * Entity to measure the dimension to
   */
  to_entity_id: string
  /**
   * Normalized position within the entity to position the dimension to
   */
  to_entity_pos: Point2d<number>
  /**
   * Basic dimension parameters (symbol and tolerance)
   */
  dimension: AnnotationMbdBasicDimension
  /**
   * Orientation plane.  The annotation will lie in this plane which is positioned about the leader position as its origin.
   */
  plane_id: string
  /**
   * 2D Position offset of the annotation within the plane.
   */
  offset: Point2d<number>
  /**
   * Number of decimal places to use when displaying tolerance and dimension values
   */
  precision: number
  /**
   * The scale of the font label in 3D space
   */
  font_scale: number
  /**
   * The point size of the fonts used to generate the annotation label.  Very large values can negatively affect performance.
   */
  font_point_size: number
}

/**
 * Parameters for defining an MBD Feature Control Annotation state
 */
export type AnnotationFeatureControl = {
  /**
   * Entity to place the annotation leader from
   */
  entity_id: string
  /**
   * Normalized position within the entity to position the annotation leader from
   */
  entity_pos: Point2d<number>
  /**
   * Type of leader to use
   */
  leader_type: AnnotationLineEnd
  /**
   * Basic dimensions
   */
  dimension: AnnotationMbdBasicDimension | null
  /**
   * MBD Control frame for geometric control
   */
  control_frame: AnnotationMbdControlFrame | null
  /**
   * Set if this annotation is defining a datum
   */
  defined_datum: string | null
  /**
   * Prefix text which will appear before the basic dimension
   */
  prefix: string | null
  /**
   * Suffix text which will appear after the basic dimension
   */
  suffix: string | null
  /**
   * Orientation plane.  The annotation will lie in this plane which is positioned about the leader position as its origin.
   */
  plane_id: string
  /**
   * 2D Position offset of the annotation within the plane.
   */
  offset: Point2d<number>
  /**
   * Number of decimal places to use when displaying tolerance and dimension values
   */
  precision: number
  /**
   * The scale of the font label in 3D space
   */
  font_scale: number
  /**
   * The point size of the fonts used to generate the annotation label.  Very large values can negatively affect performance.
   */
  font_point_size: number
}

/**
 * Parameters for defining an MBD Feature Tag Annotation state
 */
export type AnnotationFeatureTag = {
  /**
   * Entity to place the annotation leader from
   */
  entity_id: string
  /**
   * Normalized position within the entity to position the annotation leader from
   */
  entity_pos: Point2d<number>
  /**
   * Type of leader to use
   */
  leader_type: AnnotationLineEnd
  /**
   * Tag key
   */
  key: string
  /**
   * Tag value
   */
  value: string
  /**
   * Whether or not to display the key on the annotation label
   */
  show_key: boolean
  /**
   * Orientation plane.  The annotation will lie in this plane which is positioned about the leader position as its origin.
   */
  plane_id: string
  /**
   * 2D Position offset of the annotation within the plane.
   */
  offset: Point2d<number>
  /**
   * The scale of the font label in 3D space
   */
  font_scale: number
  /**
   * The point size of the fonts used to generate the annotation label.  Very large values can negatively affect performance.
   */
  font_point_size: number
}

/**
 * Annotation line end type
 */
export type AnnotationLineEnd = 'none' | 'arrow' | 'dot'

/**
 * Options for annotation text
 */
export type AnnotationLineEndOptions = {
  /**
   * How to style the start of the annotation line.
   */
  start: AnnotationLineEnd
  /**
   * How to style the end of the annotation line.
   */
  end: AnnotationLineEnd
}

/**
 * Parameters for defining an MBD basic dimension
 */
export type AnnotationMbdBasicDimension = {
  /**
   * Type of symbol to use for this dimension (if required)
   */
  symbol: MbdSymbol | null
  /**
   * The explicitly defined dimension.  Only required if the measurement is not automatically calculated.
   */
  dimension: number | null
  /**
   * The tolerance of the dimension
   */
  tolerance: number
}

/**
 * Parameters for defining an MBD Geometric control frame
 */
export type AnnotationMbdControlFrame = {
  /**
   *Geometric symbol, the type of geometric control specified
   */
  symbol: MbdSymbol
  /**
   * Diameter symbol (if required) whether the geometric control requires a cylindrical or diameter tolerance
   */
  diameter_symbol: MbdSymbol | null
  /**
   * Tolerance value - the total tolerance of the geometric control.  The unit is based on the drawing standard.
   */
  tolerance: number
  /**
   * Feature of size or tolerance modifiers
   */
  modifier: MbdSymbol | null
  /**
   * Primary datum
   */
  primary_datum: string | null
  /**
   * Secondary datum
   */
  secondary_datum: string | null
  /**
   * Tertiary datum
   */
  tertiary_datum: string | null
}

/**
 * Options for annotations
 */
export type AnnotationOptions = {
  /**
   * Text displayed on the annotation
   */
  text: AnnotationTextOptions | null
  /**
   * How to style the start and end of the line
   */
  line_ends: AnnotationLineEndOptions | null
  /**
   * Width of the annotation's line
   */
  line_width: number | null
  /**
   * Color to render the annotation
   */
  color: Color | null
  /**
   * Position to put the annotation
   */
  position: Point3d<number> | null
  /**
   * Set as an MBD measured basic dimension annotation
   */
  dimension: AnnotationBasicDimension | null
  /**
   * Set as an MBD Feature control annotation
   */
  feature_control: AnnotationFeatureControl | null
  /**
   * Set as a feature tag annotation
   */
  feature_tag: AnnotationFeatureTag | null
}

/**
 * Horizontal Text alignment
 */
export type AnnotationTextAlignmentX = 'left' | 'center' | 'right'

/**
 * Vertical Text alignment
 */
export type AnnotationTextAlignmentY = 'bottom' | 'center' | 'top'

/**
 * Options for annotation text
 */
export type AnnotationTextOptions = {
  /**
   * Alignment along the X axis
   */
  x: AnnotationTextAlignmentX
  /**
   * Alignment along the Y axis
   */
  y: AnnotationTextAlignmentY
  /**
   * Text displayed on the annotation
   */
  text: string
  /**
   * Text font's point size
   */
  point_size: number
}

/**
 * The type of annotation
 */
export type AnnotationType = 't2d' | 't3d'

/**
 * Co-ordinate axis specifier.
 *
 * See [cglearn.eu] for background reading.
 *
 * [cglearn.eu]: https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1
 */
export type Axis = 'y' | 'z'

/**
 * An [`Axis`] paired with a [`Direction`].
 */
export type AxisDirectionPair = {
  /**
   * Axis specifier.
   */
  axis: Axis
  /**
   * Specifies which direction the axis is pointing.
   */
  direction: Direction
}

/**
 * Create a new solid from intersecting several other solids.
 * In other words, the part of the input solids where they all overlap will be the output solid.
 */
export type BooleanIntersection = {
  /**
   * Which solids to intersect together
   */
  solid_ids: Array<string>
  /**
   * The maximum acceptable surface gap computed between the joined solids. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
}

/**
 * Create a new solid from subtracting several other solids.
 * The 'target' is what will be cut from.
 * The 'tool' is what will be cut out from 'target'.
 */
export type BooleanSubtract = {
  /**
   * Geometry to cut out from.
   */
  target_ids: Array<string>
  /**
   * Will be cut out from the 'target'.
   */
  tool_ids: Array<string>
  /**
   * The maximum acceptable surface gap computed between the target and the solids cut out from it. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
}

/**
 * Create a new solid from combining other smaller solids.
 * In other words, every part of the input solids will be included in the output solid.
 */
export type BooleanUnion = {
  /**
   * Which solids to union together.
   * Cannot be empty.
   */
  solid_ids: Array<string>
  /**
   * The maximum acceptable surface gap computed between the joined solids. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
}

/**
 * Camera drag ended
 */
export type CameraDragEnd = {
  /**
   * The type of camera drag interaction.
   */
  interaction: CameraDragInteractionType
  /**
   * The final mouse position.
   */
  window: Point2d<number>
}

/**
 * The type of camera drag interaction.
 */
export type CameraDragInteractionType =
  | 'pan'
  | 'rotate'
  | 'rotatetrackball'
  | 'zoom'

/**
 * Camera drag continued.
 */
export type CameraDragMove = {
  /**
   * The type of camera drag interaction.
   */
  interaction: CameraDragInteractionType
  /**
   * The current mouse position.
   */
  window: Point2d<number>
  /**
   * Logical timestamp. The client should increment this
   * with every event in the current mouse drag. That way, if the
   * events are being sent over an unordered channel, the API
   * can ignore the older events.
   */
  sequence: number | null
}

/**
 * Camera drag started.
 */
export type CameraDragStart = {
  /**
   * The type of camera drag interaction.
   */
  interaction: CameraDragInteractionType
  /**
   * The initial mouse position.
   */
  window: Point2d<number>
}

/**
 * A type of camera movement applied after certain camera operations
 */
export type CameraMovement = 'vantage' | 'none'

export type CameraViewState = {
  pivot_rotation: Point4d<number>
  pivot_position: Point3d<number>
  eye_offset: number
  fov_y: number
  ortho_scale_factor: number
  is_ortho: boolean
  ortho_scale_enabled: boolean
  world_coord_system: WorldCoordinateSystem
}

/**
 * Get the center of mass of entities in the scene or the default scene.
 */
export type CenterOfMass = {
  /**
   * IDs of the entities to get the center of mass of. If this is empty, then the default scene is included in
   * the center of mass.
   */
  entity_ids: Array<string>
  /**
   * The output unit for the center of mass.
   */
  output_unit: UnitLength
}

/**
 * Closes a path, converting it to a 2D solid.
 */
export type ClosePath = {
  /**
   * Which path to close.
   */
  path_id: string
}

/**
 * An RGBA color
 */
export type Color = {
  /**
   * Red
   */
  r: number
  /**
   * Green
   */
  g: number
  /**
   * Blue
   */
  b: number
  /**
   * Alpha
   */
  a: number
}

/**
 * Container that holds a translate, rotate and scale.
 * Defaults to no change, everything stays the same (i.e. the identity function).
 */
export type ComponentTransform = {
  /**
   * Translate component of the transform.
   */
  translate: TransformBy<Point3d<LengthUnit>> | null
  /**
   * Rotate component of the transform.
   * The rotation is specified as a roll, pitch, yaw.
   */
  rotate_rpy: TransformBy<Point3d<number>> | null
  /**
   * Rotate component of the transform.
   * The rotation is specified as an axis and an angle (xyz are the components of the axis, w is
   * the angle in degrees).
   */
  rotate_angle_axis: TransformBy<Point4d<number>> | null
  /**
   * Scale component of the transform.
   */
  scale: TransformBy<Point3d<number>> | null
}

/**
 * Get control points of the given curve.
 */
export type CurveGetControlPoints = {
  /**
   * Which curve to query.
   */
  curve_id: string
}

/**
 * Find the start and end of a curve.
 */
export type CurveGetEndPoints = {
  /**
   * ID of the curve being queried.
   */
  curve_id: string
}

/**
 * Get type of the given curve.
 */
export type CurveGetType = {
  /**
   * Which curve to query.
   */
  curve_id: string
}

/**
 * Get the plane for sketch mode.
 */
export type CurveSetConstraint = {
  /**
   * Which curve to constrain.
   */
  object_id: string
  /**
   * Which constraint to apply.
   */
  constraint_bound: PathComponentConstraintBound
  /**
   * What part of the curve should be constrained.
   */
  constraint_type: PathComponentConstraintType
}

/**
 * What strategy (algorithm) should be used for cutting?
 * Defaults to Automatic.
 */
export type CutStrategy = 'basic' | 'csg' | 'automatic'

/**
 * What kind of cut to do
 */
export type CutType = 'fillet' | 'chamfer'

/**
 *Updates the camera to center to the center of the current scene's bounds
 */
export type DefaultCameraCenterToScene = {
  /**
   * Dictates whether or not the camera position should be adjusted during this operation
   * If no movement is requested, the camera will orbit around the new center from its current position
   */
  camera_movement: CameraMovement
}

/**
 *Updates the camera to center to the center of the current selection
 *(or the origin if nothing is selected)
 */
export type DefaultCameraCenterToSelection = {
  /**
   * Dictates whether or not the camera position should be adjusted during this operation
   * If no movement is requested, the camera will orbit around the new center from its current position
   */
  camera_movement: CameraMovement
}

/**
 * Focus the default camera upon an object in the scene.
 */
export type DefaultCameraFocusOn = {
  /**
   * UUID of object to focus on.
   */
  uuid: string
}

/**
 * Gets the default camera's camera settings
 */
export type DefaultCameraGetSettings = Record<string, never>

/**
 * Gets the default camera's view state
 */
export type DefaultCameraGetView = Record<string, never>

/**
 * Change what the default camera is looking at.
 */
export type DefaultCameraLookAt = {
  /**
   * Where the camera is positioned
   */
  vantage: Point3d<number>
  /**
   * What the camera is looking at. Center of the camera's field of vision
   */
  center: Point3d<number>
  /**
   * Which way is "up", from the camera's point of view.
   */
  up: Point3d<number>
  /**
   * Logical timestamp. The client should increment this
   * with every event in the current mouse drag. That way, if the
   * events are being sent over an unordered channel, the API
   * can ignore the older events.
   */
  sequence: number | null
}

/**
 * Change what the default camera is looking at.
 */
export type DefaultCameraPerspectiveSettings = {
  /**
   * Where the camera is positioned
   */
  vantage: Point3d<number>
  /**
   * What the camera is looking at. Center of the camera's field of vision
   */
  center: Point3d<number>
  /**
   * Which way is "up", from the camera's point of view.
   */
  up: Point3d<number>
  /**
   * The field of view angle in the y direction, in degrees.
   */
  fov_y: number | null
  /**
   * The distance to the near clipping plane.
   */
  z_near: number | null
  /**
   * The distance to the far clipping plane.
   */
  z_far: number | null
  /**
   * Logical timestamp. The client should increment this
   * with every event in the current mouse drag. That way, if the
   * events are being sent over an unordered channel, the API
   * can ignore the older events.
   */
  sequence: number | null
}

/**
 * Use orthographic projection.
 */
export type DefaultCameraSetOrthographic = Record<string, never>

/**
 * Use perspective projection.
 */
export type DefaultCameraSetPerspective = {
  /**
   * If this is not given, use the same parameters as last time the perspective camera was used.
   */
  parameters: PerspectiveCameraParameters | null
}

/**
 * Sets the default camera's view state
 */
export type DefaultCameraSetView = {
  /**
   * Camera view state
   */
  view: CameraViewState
}

/**
 * Adjust zoom of the default camera.
 */
export type DefaultCameraZoom = {
  /**
   * Move the camera forward along the vector it's looking at,
   * by this magnitudedefaultCameraZoom.
   * Basically, how much should the camera move forward by.
   */
  magnitude: number
}

/**
 * Get the density of entities in the scene or the default scene.
 */
export type Density = {
  /**
   * IDs of the entities to get the density of. If this is empty, then the default scene is included in
   * the density.
   */
  entity_ids: Array<string>
  /**
   * The material mass.
   */
  material_mass: number
  /**
   * The material mass unit.
   */
  material_mass_unit: UnitMass
  /**
   * The output unit for the density.
   */
  output_unit: UnitDensity
}

/**
 * Specifies the sign of a co-ordinate axis.
 */
export type Direction = 'positive' | 'negative'

/**
 * Sets whether or not changes to the scene or its objects will be done as a "dry run"
 * In a dry run, successful commands won't actually change the model.
 * This is useful for catching errors before actually making the change.
 */
export type DisableDryRun = Record<string, never>

/**
 * The type of distance
 * Distances can vary depending on
 * the objects used as input.
 */
export type DistanceType =
  | { type: 'euclidean' }
  | {
      type: 'on_axis'
      /**
       * Global axis
       */
      axis: GlobalAxis
    }

/**
 * Options for exporting DXF format.
 */
export type DxfExportOptions = {
  /**
   * Export storage.
   */
  storage: DxfStorage
}

/**
 * Export storage.
 */
export type DxfStorage = 'ascii' | 'binary'

/**
 * Changes visibility of scene-wide edge lines on brep solids
 */
export type EdgeLinesVisible = {
  /**
   * Whether or not the edge lines should be hidden.
   */
  hidden: boolean
}

/**
 * Sets whether or not changes to the scene or its objects will be done as a "dry run"
 * In a dry run, successful commands won't actually change the model.
 * This is useful for catching errors before actually making the change.
 */
export type EnableDryRun = Record<string, never>

/**
 * Sketch on some entity (e.g. a plane, a face).
 */
export type EnableSketchMode = {
  /**
   * Which entity to sketch on.
   */
  entity_id: string
  /**
   * Should the camera use orthographic projection?
   * In other words, should an object's size in the rendered image stay constant regardless of its distance from the camera.
   */
  ortho: boolean
  /**
   * Should we animate or snap for the camera transition?
   */
  animated: boolean
  /**
   * Should the camera move at all?
   */
  adjust_camera: boolean
  /**
   * If provided, ensures that the normal of the sketch plane must be aligned with this supplied normal
   * (otherwise the camera position will be used to infer the normal to point towards the viewer)
   */
  planar_normal: Point3d<number> | null
}

/**
 * Evaluates the position of a path in one shot (engine utility for kcl executor)
 */
export type EngineUtilEvaluatePath = {
  /**
   * The path in json form (the serialized result of the kcl Sketch/Path object
   */
  path_json: string
  /**
   * The evaluation parameter (path curve parameter in the normalized domain [0, 1])
   */
  t: number
}

/**
 * Create a circular pattern using this entity.
 */
export type EntityCircularPattern = {
  /**
   * ID of the entity being copied.
   */
  entity_id: string
  /**
   * Axis around which to make the copies.
   * For Solid2d patterns, this is ignored.
   */
  axis: Point3d<number>
  /**
   * Point around which to make the copies.
   * For Solid2d patterns, the z component is ignored.
   */
  center: Point3d<LengthUnit>
  /**
   * Number of repetitions to make.
   */
  num_repetitions: number
  /**
   * Arc angle (in degrees) to place repetitions along.
   */
  arc_degrees: number
  /**
   * Whether or not to rotate the objects as they are copied.
   */
  rotate_duplicates: boolean
}

/**
 * Create a pattern using this entity by specifying the transform for each desired repetition.
 * Transformations are performed in the following order (first applied to last applied): scale, rotate, translate.
 */
export type EntityClone = {
  /**
   * ID of the entity being cloned.
   */
  entity_id: string
}

/**
 * Fade entity in or out.
 */
export type EntityFade = {
  /**
   * Which entity is being changed.
   */
  entity_id: string
  /**
   * Fade in = true, fade out = false.
   */
  fade_in: boolean
  /**
   * How many seconds the animation should take.
   */
  duration_seconds: number
}

/**
 * What are all UUIDs of this entity's children?
 */
export type EntityGetAllChildUuids = {
  /**
   * ID of the entity being queried.
   */
  entity_id: string
}

/**
 * What is the UUID of this entity's n-th child?
 */
export type EntityGetChildUuid = {
  /**
   * ID of the entity being queried.
   */
  entity_id: string
  /**
   * Index into the entity's list of children.
   */
  child_index: number
}

/**
 * What is the distance between these two entities?
 */
export type EntityGetDistance = {
  /**
   * ID of the first entity being queried.
   */
  entity_id1: string
  /**
   * ID of the second entity being queried.
   */
  entity_id2: string
  /**
   * Type of distance to be measured.
   */
  distance_type: DistanceType
}

/**
 * How many children does the entity have?
 */
export type EntityGetNumChildren = {
  /**
   * ID of the entity being queried.
   */
  entity_id: string
}

/**
 * What is this entity's parent?
 */
export type EntityGetParentId = {
  /**
   * ID of the entity being queried.
   */
  entity_id: string
}

/**
 * What are all UUIDs of all the paths sketched on top of this entity?
 */
export type EntityGetSketchPaths = {
  /**
   * ID of the entity being queried.
   */
  entity_id: string
}

/**
 * Create a linear pattern using this entity.
 */
export type EntityLinearPattern = {
  /**
   * ID of the entity being copied.
   */
  entity_id: string
  /**
   * Axis along which to make the copies.
   * For Solid2d patterns, the z component is ignored.
   */
  axis: Point3d<number>
  /**
   * Number of repetitions to make.
   */
  num_repetitions: number
  /**
   * Spacing between repetitions.
   */
  spacing: LengthUnit
}

/**
 * Create a pattern using this entity by specifying the transform for each desired repetition.
 * Transformations are performed in the following order (first applied to last applied): scale, rotate, translate.
 */
export type EntityLinearPatternTransform = {
  /**
   * ID of the entity being copied.
   */
  entity_id: string
  /**
   * How to transform each repeated solid.
   * The 0th transform will create the first copy of the entity.
   * The total number of (optional) repetitions equals the size of this list.
   */
  transform: Array<Transform>
  /**
   * Alternatively, you could set this key instead.
   * If you want to use multiple transforms per item.
   * If this is non-empty then the `transform` key must be empty, and vice-versa.
   */
  transforms: Array<Array<Transform>>
}

/**
 * Create a helix using the input cylinder and other specified parameters.
 */
export type EntityMakeHelix = {
  /**
   * ID of the cylinder.
   */
  cylinder_id: string
  /**
   * Number of revolutions.
   */
  revolutions: number
  /**
   * Start angle.
   */
  start_angle: Angle
  /**
   * Is the helix rotation clockwise?
   */
  is_clockwise: boolean
  /**
   * Length of the helix. If None, the length of the cylinder will be used instead.
   */
  length: LengthUnit | null
}

/**
 * Create a helix using the specified parameters.
 */
export type EntityMakeHelixFromEdge = {
  /**
   * Radius of the helix.
   */
  radius: LengthUnit
  /**
   * Length of the helix. If None, the length of the edge will be used instead.
   */
  length: LengthUnit | null
  /**
   * Number of revolutions.
   */
  revolutions: number
  /**
   * Start angle.
   */
  start_angle: Angle
  /**
   * Is the helix rotation clockwise?
   */
  is_clockwise: boolean
  /**
   * Edge about which to make the helix.
   */
  edge_id: string
}

/**
 * Create a helix using the specified parameters.
 */
export type EntityMakeHelixFromParams = {
  /**
   * Radius of the helix.
   */
  radius: LengthUnit
  /**
   * Length of the helix.
   */
  length: LengthUnit
  /**
   * Number of revolutions.
   */
  revolutions: number
  /**
   * Start angle.
   */
  start_angle: Angle
  /**
   * Is the helix rotation clockwise?
   */
  is_clockwise: boolean
  /**
   * Center of the helix at the base of the helix.
   */
  center: Point3d<LengthUnit>
  /**
   * Axis of the helix. The helix will be created around and in the direction of this axis.
   */
  axis: Point3d<number>
}

/**
 * Mirror the input entities over the specified axis. (Currently only supports sketches)
 */
export type EntityMirror = {
  /**
   * ID of the mirror entities.
   */
  ids: Array<string>
  /**
   * Axis to use as mirror.
   */
  axis: Point3d<number>
  /**
   * Point through which the mirror axis passes.
   */
  point: Point3d<LengthUnit>
}

/**
 * Mirror the input entities over the specified edge. (Currently only supports sketches)
 */
export type EntityMirrorAcrossEdge = {
  /**
   * ID of the mirror entities.
   */
  ids: Array<string>
  /**
   * The edge to use as the mirror axis, must be linear and lie in the plane of the solid
   */
  edge_id: string
}

/**
 * Set opacity of the entity.
 */
export type EntitySetOpacity = {
  /**
   * Which entity is being changed.
   */
  entity_id: string
  /**
   * How transparent should it be?
   * 0 or lower is totally transparent.
   * 1 or greater is totally opaque.
   */
  opacity: number
}

/**
 * The type of entity
 */
export type EntityType =
  | 'entity'
  | 'object'
  | 'path'
  | 'curve'
  | 'solid2d'
  | 'solid3d'
  | 'edge'
  | 'face'
  | 'plane'
  | 'vertex'

/**
 * Export the scene to a file.
 */
export type Export = {
  /**
   * IDs of the entities to be exported. If this is empty, then all entities are exported.
   */
  entity_ids: Array<string>
  /**
   * The file format to export to.
   */
  format: OutputFormat3d
}

/**
 * Export a sketch to a file.
 */
export type Export2d = {
  /**
   * IDs of the entities to be exported.
   */
  entity_ids: Array<string>
  /**
   * The file format to export to.
   */
  format: OutputFormat2d
}

/**
 * Export the scene to a file.
 */
export type Export3d = {
  /**
   * IDs of the entities to be exported. If this is empty, then all entities are exported.
   */
  entity_ids: Array<string>
  /**
   * The file format to export to.
   */
  format: OutputFormat3d
}

/**
 * Extend a path by adding a new segment which starts at the path's "pen".
 * If no "pen" location has been set before (via `MovePen`), then the pen is at the origin.
 */
export type ExtendPath = {
  /**
   * The ID of the command which created the path.
   */
  path: ModelingCmdId
  /**
   * Segment to append to the path.
   * This segment will implicitly begin at the current "pen" location.
   */
  segment: PathSegment
  /**
   * Optional label to associate with the new path segment.
   */
  label?: string | null
}

/**
 * Command for extruding a solid 2d.
 */
export type Extrude = {
  /**
   * Which sketch to extrude.
   * Must be a closed 2D solid.
   */
  target: ModelingCmdId
  /**
   * How far off the plane to extrude
   */
  distance: LengthUnit
  /**
   * Which IDs should the new faces have?
   * If this isn't given, the engine will generate IDs.
   */
  faces: ExtrudedFaceInfo | null
  /**
   * Should the extrusion also extrude in the opposite direction?
   * If so, this specifies its distance.
   */
  opposite: Opposite<LengthUnit>
  /**
   * Should the extrusion create a new object or be part of the existing object.
   */
  extrude_method: ExtrudeMethod
}

/**
 * Extrusion method determining if the extrusion will be part of the existing object or an
 * entirely new object.
 */
export type ExtrudeMethod = 'new' | 'merge'

/**
 * Type of reference geometry to extrude to.
 */
export type ExtrudeReference =
  | {
      entity_reference: {
        /**
         * The UUID of the entity to extrude to.
         */
        entity_id: string
      }
    }
  | {
      axis: {
        /**
         * The axis to extrude to.
         */
        axis: Point3d<number>
        /**
         * Point the axis goes through.
         * Defaults to (0, 0, 0).
         */
        point: Point3d<LengthUnit>
      }
    }
  | {
      point: {
        /**
         * The point to extrude to.
         */
        point: Point3d<LengthUnit>
      }
    }

/**
 * Command for extruding a solid 2d to a reference geometry.
 */
export type ExtrudeToReference = {
  /**
   * Which sketch to extrude.
   * Must be a closed 2D solid.
   */
  target: ModelingCmdId
  /**
   * Reference to extrude to.
   * Extrusion occurs along the target's normal until it is as close to the reference as possible.
   */
  reference: ExtrudeReference
  /**
   * Which IDs should the new faces have?
   * If this isn't given, the engine will generate IDs.
   */
  faces: ExtrudedFaceInfo | null
  /**
   * Should the extrusion create a new object or be part of the existing object.
   */
  extrude_method: ExtrudeMethod
}

/**
 * IDs for the extruded faces.
 */
export type ExtrudedFaceInfo = {
  /**
   * The face made from the original 2D shape being extruded.
   * If the solid is extruded from a shape which already has an ID
   * (e.g. extruding something which was sketched on a face), this
   * doesn't need to be sent.
   */
  bottom: string | null
  /**
   * Top face of the extrusion (parallel and further away from the original 2D shape being extruded).
   */
  top: string
  /**
   * Any intermediate sides between the top and bottom.
   */
  sides: Array<SideFace>
}

/**
 *Obtains the surface "center of mass"
 */
export type FaceGetCenter = {
  /**
   * Which face is being queried.
   */
  object_id: string
}

/**
 * Determines the gradient (dFdu, dFdv) + normal vector on a brep face evaluated by parameters u,v
 */
export type FaceGetGradient = {
  /**
   * Which face is being queried.
   */
  object_id: string
  /**
   * The 2D parameter-space u,v position to evaluate the surface at
   */
  uv: Point2d<number>
}

/**
 * Determines a position on a brep face evaluated by parameters u,v
 */
export type FaceGetPosition = {
  /**
   * Which face is being queried.
   */
  object_id: string
  /**
   * The 2D parameter-space u,v position to evaluate the surface at
   */
  uv: Point2d<number>
}

/**
 * Determines whether a brep face is planar and returns its surface-local planar axes if so
 */
export type FaceIsPlanar = {
  /**
   * Which face is being queried.
   */
  object_id: string
}

/**
 * Options for exporting FBX.
 */
export type FbxExportOptions = {
  /**
   * Specifies which kind of FBX will be exported.
   */
  storage: FbxStorage
  /**
   * Timestamp override.
   */
  created: string | null
}

/**
 * Options for importing FBX.
 */
export type FbxImportOptions = Record<string, never>

/**
 * Describes the storage format of an FBX file.
 */
export type FbxStorage = 'ascii' | 'binary'

/**
 * What type of entity is this?
 */
export type GetEntityType = {
  /**
   * ID of the entity being queried.
   */
  entity_id: string
}

/**
 * Get the number of objects in the scene
 */
export type GetNumObjects = Record<string, never>

/**
 * Get the plane for sketch mode.
 */
export type GetSketchModePlane = Record<string, never>

/**
 * The global axes.
 */
export type GlobalAxis = 'x' | 'y' | 'z'

/**
 * Options for exporting glTF 2.0.
 */
export type GltfExportOptions = {
  /**
   * Specifies which kind of glTF 2.0 will be exported.
   */
  storage: GltfStorage
  /**
   * Specifies how the JSON will be presented.
   */
  presentation: GltfPresentation
}

/**
 * Options for importing glTF 2.0.
 */
export type GltfImportOptions = Record<string, never>

/**
 * Describes the presentation style of the glTF JSON.
 */
export type GltfPresentation = 'compact' | 'pretty'

/**
 * Describes the storage format of a glTF 2.0 scene.
 */
export type GltfStorage = 'binary' | 'standard' | 'embedded'

/**
 * Stop dragging the mouse.
 */
export type HandleMouseDragEnd = {
  /**
   * The mouse position.
   */
  window: Point2d<number>
}

/**
 * Continue dragging the mouse.
 */
export type HandleMouseDragMove = {
  /**
   * The mouse position.
   */
  window: Point2d<number>
  /**
   * Logical timestamp. The client should increment this
   * with every event in the current mouse drag. That way, if the
   * events are being sent over an unordered channel, the API
   * can ignore the older events.
   */
  sequence: number | null
}

/**
 * Start dragging the mouse.
 */
export type HandleMouseDragStart = {
  /**
   * The mouse position.
   */
  window: Point2d<number>
}

/**
 * Changes the current highlighted entity to these entities.
 */
export type HighlightSetEntities = {
  /**
   * Highlight these entities.
   */
  entities: Array<string>
}

/**
 * Changes the current highlighted entity to whichever one is at the given window coordinate.
 * If there's no entity at this location, clears the highlight.
 */
export type HighlightSetEntity = {
  /**
   * Coordinates of the window being clicked
   */
  selected_at_window: Point2d<number>
  /**
   * Logical timestamp. The client should increment this
   * with every event in the current mouse drag. That way, if the
   * events are being sent over an unordered channel, the API
   * can ignore the older events.
   */
  sequence: number | null
}

/**
 * Enum containing the variety of image formats snapshots may be exported to.
 */
export type ImageFormat = 'png' | 'jpeg'

/**
 * File to import into the current model.
 * If you are sending binary data for a file, be sure to send the WebSocketRequest as
 * binary/bson, not text/json.
 */
export type ImportFile = {
  /**
   * The file's full path, including file extension.
   */
  path: string
  /**
   * The raw bytes of the file
   */
  data: Array<number>
}

/**
 * Import files to the current model.
 */
export type ImportFiles = {
  /**
   * Files to import.
   */
  files: Array<ImportFile>
  /**
   * Input file format.
   */
  format: InputFormat3d
}

/**
 * Input format specifier.
 */
export type InputFormat3d =
  | ({ type: 'fbx' } & FbxImportOptions)
  | ({ type: 'gltf' } & GltfImportOptions)
  | ({ type: 'obj' } & ObjImportOptions)
  | ({ type: 'ply' } & PlyImportOptions)
  | ({ type: 'sldprt' } & SldprtImportOptions)
  | ({ type: 'step' } & StepImportOptions)
  | ({ type: 'stl' } & StlImportOptions)

/**
 * A length unit is wrapper around an f64 that represents a length in some unit.
 */
export type LengthUnit = number

/**
 * Command for lofting sections to create a solid
 */
export type Loft = {
  /**
   * The closed section curves to create a lofted solid from.
   * Currently, these must be Solid2Ds
   */
  section_ids: Array<string>
  /**
   * Degree of the interpolation. Must be greater than zero.
   * For example, use 2 for quadratic, or 3 for cubic interpolation in the V direction.
   */
  v_degree: number
  /**
   * Attempt to approximate rational curves (such as arcs) using a bezier.
   * This will remove banding around interpolations between arcs and non-arcs.  It may produce errors in other scenarios
   * Over time, this field won't be necessary.
   */
  bez_approximate_rational: boolean
  /**
   * This can be set to override the automatically determined topological base curve, which is usually the first section encountered.
   */
  base_curve_index: number | null
  /**
   * Tolerance
   */
  tolerance: LengthUnit
}

/**
 * Add a gizmo showing the axes.
 */
export type MakeAxesGizmo = {
  /**
   * If true, axes gizmo will be placed in the corner of the screen.
   * If false, it will be placed at the origin of the scene.
   */
  gizmo_mode: boolean
  /**
   * If true, any existing drawables within the obj will be replaced (the object will be reset)
   */
  clobber: boolean
}

/**
 * Make a new path by offsetting an object by a given distance.
 * The new path's ID will be the ID of this command.
 */
export type MakeOffsetPath = {
  /**
   * The object that will be offset (can be a path, sketch, or a solid)
   */
  object_id: string
  /**
   * If the object is a solid, this is the ID of the face to base the offset on.
   * If given, and `object_id` refers to a solid, then this face on the solid will be offset.
   * If given but `object_id` doesn't refer to a solid, responds with an error.
   * If not given, then `object_id` itself will be offset directly.
   */
  face_id: string | null
  /**
   * The distance to offset the path (positive for outset, negative for inset)
   */
  offset: LengthUnit
}

/**
 * Make a new plane
 */
export type MakePlane = {
  /**
   * Origin of the plane
   */
  origin: Point3d<LengthUnit>
  /**
   * What should the plane's X axis be?
   */
  x_axis: Point3d<number>
  /**
   * What should the plane's Y axis be?
   */
  y_axis: Point3d<number>
  /**
   * What should the plane's span/extent?
   * When rendered visually, this is both the
   * width and height along X and Y axis respectively.
   */
  size: LengthUnit
  /**
   * If true, any existing drawables within the obj will be replaced (the object will be reset)
   */
  clobber: boolean
  /**
   * If true, the plane will be created but hidden initially.
   */
  hide: boolean | null
}

/**
 * Get the mass of entities in the scene or the default scene.
 */
export type Mass = {
  /**
   * IDs of the entities to get the mass of. If this is empty, then the default scene is included in
   * the mass.
   */
  entity_ids: Array<string>
  /**
   * The material density.
   */
  material_density: number
  /**
   * The material density unit.
   */
  material_density_unit: UnitDensity
  /**
   * The output unit for the mass.
   */
  output_unit: UnitMass
}

/**
 * MBD symbol type
 */
export type MbdSymbol =
  | 'none'
  | 'arclength'
  | 'between'
  | 'degrees'
  | 'plusminus'
  | 'angularity'
  | 'cylindricity'
  | 'roundness'
  | 'concentricity'
  | 'straightness'
  | 'parallelism'
  | 'flatness'
  | 'profileofline'
  | 'surfaceprofile'
  | 'symmetry'
  | 'perpendicularity'
  | 'runout'
  | 'totalrunout'
  | 'position'
  | 'centerline'
  | 'partingline'
  | 'isoenvelope'
  | 'isoenvelopenony145m'
  | 'freestate'
  | 'statisticaltolerance'
  | 'continuousfeature'
  | 'independency'
  | 'depth'
  | 'start'
  | 'leastcondition'
  | 'maxcondition'
  | 'conicaltaper'
  | 'projected'
  | 'slope'
  | 'micro'
  | 'tangentplane'
  | 'unilateral'
  | 'squarefeature'
  | 'countersink'
  | 'spotface'
  | 'target'
  | 'diameter'
  | 'radius'
  | 'sphericalradius'
  | 'sphericaldiameter'
  | 'controlledradius'
  | 'boxstart'
  | 'boxbar'
  | 'boxbarbetween'
  | 'letterbackwardunderline'
  | 'punctuationbackwardunderline'
  | 'modifierbackwardunderline'
  | 'numericbackwardunderline'
  | 'boxend'
  | 'datumup'
  | 'datumleft'
  | 'datumright'
  | 'datumdown'
  | 'datumtriangle'
  | 'halfspace'
  | 'quarterspace'
  | 'eighthspace'
  | 'modifierspace'

/**
 * Commands that the KittyCAD engine can execute.
 */
export type ModelingCmd =
  | ({ type: 'engine_util_evaluate_path' } & EngineUtilEvaluatePath)
  | ({ type: 'start_path' } & StartPath)
  | ({ type: 'move_path_pen' } & MovePathPen)
  | ({ type: 'extend_path' } & ExtendPath)
  | ({ type: 'extrude' } & Extrude)
  | ({ type: 'extrude_to_reference' } & ExtrudeToReference)
  | ({ type: 'twist_extrude' } & TwistExtrude)
  | ({ type: 'sweep' } & Sweep)
  | ({ type: 'revolve' } & Revolve)
  | ({ type: 'solid3d_shell_face' } & Solid3dShellFace)
  | ({ type: 'revolve_about_edge' } & RevolveAboutEdge)
  | ({ type: 'loft' } & Loft)
  | ({ type: 'close_path' } & ClosePath)
  | ({ type: 'camera_drag_start' } & CameraDragStart)
  | ({ type: 'camera_drag_move' } & CameraDragMove)
  | ({ type: 'camera_drag_end' } & CameraDragEnd)
  | ({ type: 'default_camera_get_settings' } & DefaultCameraGetSettings)
  | ({ type: 'default_camera_get_view' } & DefaultCameraGetView)
  | ({ type: 'default_camera_set_view' } & DefaultCameraSetView)
  | ({ type: 'default_camera_look_at' } & DefaultCameraLookAt)
  | ({
      type: 'default_camera_perspective_settings'
    } & DefaultCameraPerspectiveSettings)
  | ({ type: 'default_camera_zoom' } & DefaultCameraZoom)
  | ({ type: 'export2d' } & Export2d)
  | ({ type: 'export3d' } & Export3d)
  | ({ type: 'export' } & Export)
  | ({ type: 'entity_get_parent_id' } & EntityGetParentId)
  | ({ type: 'entity_get_num_children' } & EntityGetNumChildren)
  | ({ type: 'entity_get_child_uuid' } & EntityGetChildUuid)
  | ({ type: 'entity_get_all_child_uuids' } & EntityGetAllChildUuids)
  | ({ type: 'entity_get_sketch_paths' } & EntityGetSketchPaths)
  | ({ type: 'entity_get_distance' } & EntityGetDistance)
  | ({ type: 'entity_clone' } & EntityClone)
  | ({ type: 'entity_linear_pattern_transform' } & EntityLinearPatternTransform)
  | ({ type: 'entity_linear_pattern' } & EntityLinearPattern)
  | ({ type: 'entity_circular_pattern' } & EntityCircularPattern)
  | ({ type: 'entity_make_helix' } & EntityMakeHelix)
  | ({ type: 'entity_make_helix_from_params' } & EntityMakeHelixFromParams)
  | ({ type: 'entity_make_helix_from_edge' } & EntityMakeHelixFromEdge)
  | ({ type: 'entity_mirror' } & EntityMirror)
  | ({ type: 'entity_mirror_across_edge' } & EntityMirrorAcrossEdge)
  | ({ type: 'select_with_point' } & SelectWithPoint)
  | ({ type: 'select_add' } & SelectAdd)
  | ({ type: 'select_remove' } & SelectRemove)
  | ({ type: 'scene_clear_all' } & SceneClearAll)
  | ({ type: 'select_replace' } & SelectReplace)
  | ({ type: 'highlight_set_entity' } & HighlightSetEntity)
  | ({ type: 'highlight_set_entities' } & HighlightSetEntities)
  | ({ type: 'new_annotation' } & NewAnnotation)
  | ({ type: 'update_annotation' } & UpdateAnnotation)
  | ({ type: 'edge_lines_visible' } & EdgeLinesVisible)
  | ({ type: 'object_visible' } & ObjectVisible)
  | ({ type: 'object_bring_to_front' } & ObjectBringToFront)
  | ({ type: 'object_set_material_params_pbr' } & ObjectSetMaterialParamsPbr)
  | ({ type: 'get_entity_type' } & GetEntityType)
  | ({ type: 'solid3d_get_all_edge_faces' } & Solid3dGetAllEdgeFaces)
  | ({ type: 'solid2d_add_hole' } & Solid2dAddHole)
  | ({ type: 'solid3d_get_all_opposite_edges' } & Solid3dGetAllOppositeEdges)
  | ({ type: 'solid3d_get_opposite_edge' } & Solid3dGetOppositeEdge)
  | ({ type: 'solid3d_get_next_adjacent_edge' } & Solid3dGetNextAdjacentEdge)
  | ({ type: 'solid3d_get_prev_adjacent_edge' } & Solid3dGetPrevAdjacentEdge)
  | ({ type: 'solid3d_get_common_edge' } & Solid3dGetCommonEdge)
  | ({ type: 'solid3d_fillet_edge' } & Solid3dFilletEdge)
  | ({ type: 'face_is_planar' } & FaceIsPlanar)
  | ({ type: 'face_get_position' } & FaceGetPosition)
  | ({ type: 'face_get_center' } & FaceGetCenter)
  | ({ type: 'face_get_gradient' } & FaceGetGradient)
  | ({ type: 'send_object' } & SendObject)
  | ({ type: 'entity_set_opacity' } & EntitySetOpacity)
  | ({ type: 'entity_fade' } & EntityFade)
  | ({ type: 'make_plane' } & MakePlane)
  | ({ type: 'plane_set_color' } & PlaneSetColor)
  | ({ type: 'set_tool' } & SetTool)
  | ({ type: 'mouse_move' } & MouseMove)
  | ({ type: 'mouse_click' } & MouseClick)
  | ({ type: 'sketch_mode_disable' } & SketchModeDisable)
  | ({ type: 'get_sketch_mode_plane' } & GetSketchModePlane)
  | ({ type: 'curve_set_constraint' } & CurveSetConstraint)
  | ({ type: 'enable_sketch_mode' } & EnableSketchMode)
  | ({ type: 'enable_dry_run' } & EnableDryRun)
  | ({ type: 'disable_dry_run' } & DisableDryRun)
  | ({ type: 'set_background_color' } & SetBackgroundColor)
  | ({ type: 'set_current_tool_properties' } & SetCurrentToolProperties)
  | ({ type: 'set_default_system_properties' } & SetDefaultSystemProperties)
  | ({ type: 'curve_get_type' } & CurveGetType)
  | ({ type: 'curve_get_control_points' } & CurveGetControlPoints)
  | ({ type: 'project_entity_to_plane' } & ProjectEntityToPlane)
  | ({ type: 'project_points_to_plane' } & ProjectPointsToPlane)
  | ({ type: 'take_snapshot' } & TakeSnapshot)
  | ({ type: 'make_axes_gizmo' } & MakeAxesGizmo)
  | ({ type: 'path_get_info' } & PathGetInfo)
  | ({
      type: 'path_get_curve_uuids_for_vertices'
    } & PathGetCurveUuidsForVertices)
  | ({ type: 'path_get_curve_uuid' } & PathGetCurveUuid)
  | ({ type: 'path_get_vertex_uuids' } & PathGetVertexUuids)
  | ({ type: 'path_get_sketch_target_uuid' } & PathGetSketchTargetUuid)
  | ({ type: 'handle_mouse_drag_start' } & HandleMouseDragStart)
  | ({ type: 'handle_mouse_drag_move' } & HandleMouseDragMove)
  | ({ type: 'handle_mouse_drag_end' } & HandleMouseDragEnd)
  | ({ type: 'remove_scene_objects' } & RemoveSceneObjects)
  | ({ type: 'plane_intersect_and_project' } & PlaneIntersectAndProject)
  | ({ type: 'curve_get_end_points' } & CurveGetEndPoints)
  | ({ type: 'reconfigure_stream' } & ReconfigureStream)
  | ({ type: 'import_files' } & ImportFiles)
  | ({ type: 'set_scene_units' } & SetSceneUnits)
  | ({ type: 'mass' } & Mass)
  | ({ type: 'density' } & Density)
  | ({ type: 'volume' } & Volume)
  | ({ type: 'center_of_mass' } & CenterOfMass)
  | ({ type: 'surface_area' } & SurfaceArea)
  | ({ type: 'default_camera_focus_on' } & DefaultCameraFocusOn)
  | ({ type: 'set_selection_type' } & SetSelectionType)
  | ({ type: 'set_selection_filter' } & SetSelectionFilter)
  | ({ type: 'default_camera_set_orthographic' } & DefaultCameraSetOrthographic)
  | ({ type: 'default_camera_set_perspective' } & DefaultCameraSetPerspective)
  | ({
      type: 'default_camera_center_to_selection'
    } & DefaultCameraCenterToSelection)
  | ({ type: 'default_camera_center_to_scene' } & DefaultCameraCenterToScene)
  | ({ type: 'zoom_to_fit' } & ZoomToFit)
  | ({ type: 'orient_to_face' } & OrientToFace)
  | ({ type: 'view_isometric' } & ViewIsometric)
  | ({ type: 'solid3d_get_extrusion_face_info' } & Solid3dGetExtrusionFaceInfo)
  | ({ type: 'solid3d_get_adjacency_info' } & Solid3dGetAdjacencyInfo)
  | ({ type: 'select_clear' } & SelectClear)
  | ({ type: 'select_get' } & SelectGet)
  | ({ type: 'get_num_objects' } & GetNumObjects)
  | ({ type: 'set_object_transform' } & SetObjectTransform)
  | ({ type: 'boolean_union' } & BooleanUnion)
  | ({ type: 'boolean_intersection' } & BooleanIntersection)
  | ({ type: 'boolean_subtract' } & BooleanSubtract)
  | ({ type: 'make_offset_path' } & MakeOffsetPath)
  | ({ type: 'add_hole_from_offset' } & AddHoleFromOffset)
  | ({ type: 'set_grid_reference_plane' } & SetGridReferencePlane)
  | ({ type: 'set_grid_scale' } & SetGridScale)
  | ({ type: 'set_grid_auto_scale' } & SetGridAutoScale)

/**
 * All commands have unique IDs. These should be randomly generated.
 */
export type ModelingCmdId = string

/**
 * Send a mouse click event
 * Updates modified/selected entities.
 */
export type MouseClick = {
  /**
   * Where the mouse is
   */
  window: Point2d<number>
}

/**
 * Send a mouse move event
 */
export type MouseMove = {
  /**
   * Where the mouse is
   */
  window: Point2d<number>
  /**
   * Logical timestamp. The client should increment this
   * with every event in the current mouse drag. That way, if the
   * events are being sent over an unordered channel, the API
   * can ignore the older events.
   */
  sequence: number | null
}

/**
 * Move the path's "pen".
 * If you're in sketch mode, these coordinates are in the local coordinate system,
 * not the world's coordinate system.
 * For example, say you're sketching on the plane {x: (1,0,0), y: (0,1,0), origin: (0, 0, 50)}.
 * In other words, the plane 50 units above the default XY plane. Then, moving the pen
 * to (1, 1, 0) with this command uses local coordinates. So, it would move the pen to
 * (1, 1, 50) in global coordinates.
 */
export type MovePathPen = {
  /**
   * The ID of the command which created the path.
   */
  path: ModelingCmdId
  /**
   * Where the path's pen should be.
   */
  to: Point3d<LengthUnit>
}

/**
 * Create a new annotation
 */
export type NewAnnotation = {
  /**
   * What should the annotation contain?
   */
  options: AnnotationOptions
  /**
   * If true, any existing drawables within the obj will be replaced (the object will be reset)
   */
  clobber: boolean
  /**
   * What type of annotation to create.
   */
  annotation_type: AnnotationType
}

/**
 * Options for exporting OBJ.
 */
export type ObjExportOptions = {
  /**
   * Co-ordinate system of output data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * Export length unit.
   *
   * Defaults to millimeters.
   */
  units: UnitLength
}

/**
 * Options for importing OBJ.
 */
export type ObjImportOptions = {
  /**
   * Co-ordinate system of input data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * The units of the input data.
   *
   * This is very important for correct scaling and when calculating physics properties like
   * mass, etc.
   *
   * Defaults to millimeters.
   */
  units: UnitLength
}

/**
 * Bring an object to the front of the scene
 */
export type ObjectBringToFront = {
  /**
   * Which object to change
   */
  object_id: string
}

/**
 * Set the material properties of an object
 */
export type ObjectSetMaterialParamsPbr = {
  /**
   * Which object to change
   */
  object_id: string
  /**
   * Color of the new material
   */
  color: Color
  /**
   * Metalness of the new material
   */
  metalness: number
  /**
   * Roughness of the new material
   */
  roughness: number
  /**
   * Ambient Occlusion of the new material
   */
  ambient_occlusion: number
}

/**
 * Hide or show an object
 */
export type ObjectVisible = {
  /**
   * Which object to change
   */
  object_id: string
  /**
   * Whether or not the object should be hidden.
   */
  hidden: boolean
}

/**
 *If bidirectional or symmetric operations are needed this enum encapsulates the required
 *information.
 */
export type Opposite<T> = 'None' | 'Symmetric' | { Other: T }

/**
 * Looks along the normal of the specified face (if it is planar!), and fits the view to it.
 */
export type OrientToFace = {
  /**
   * Which face to orient camera to. If the face is not planar, no action will occur.
   */
  face_id: string
  /**
   * How much to pad the view frame by, as a fraction of the face bounding box size.
   * Negative padding will crop the view of the face proportionally.
   * e.g. padding = 0.2 means the view will span 120% of the face bounding box,
   * and padding = -0.2 means the view will span 80% of the face bounding box.
   */
  padding: number
  /**
   * Whether or not to animate the camera movement. (Animation is currently not supported.)
   */
  animated: boolean
}

/**
 * The type of origin
 */
export type OriginType =
  | { type: 'local' }
  | { type: 'global' }
  | {
      type: 'custom'
      /**
       * Custom origin point.
       */
      origin: Point3d<number>
    }

/**
 * Output 2D format specifier.
 */
export type OutputFormat2d = { type: 'dxf' } & DxfExportOptions

/**
 * Output 3D format specifier.
 */
export type OutputFormat3d =
  | ({ type: 'fbx' } & FbxExportOptions)
  | ({ type: 'gltf' } & GltfExportOptions)
  | ({ type: 'obj' } & ObjExportOptions)
  | ({ type: 'ply' } & PlyExportOptions)
  | ({ type: 'step' } & StepExportOptions)
  | ({ type: 'stl' } & StlExportOptions)

/**
 * The path component constraint bounds type
 */
export type PathComponentConstraintBound =
  | 'unconstrained'
  | 'partially_constrained'
  | 'fully_constrained'

/**
 * The path component constraint type
 */
export type PathComponentConstraintType =
  | 'unconstrained'
  | 'vertical'
  | 'horizontal'
  | 'equal_length'
  | 'parallel'
  | 'angle_between'

/**
 * Obtain curve id by index
 */
export type PathGetCurveUuid = {
  /**
   * Which path to query
   */
  path_id: string
  /**
   * IDs of the vertices for which to obtain curve ids from
   */
  index: number
}

/**
 * Obtain curve ids for vertex ids
 */
export type PathGetCurveUuidsForVertices = {
  /**
   * Which path to query
   */
  path_id: string
  /**
   * IDs of the vertices for which to obtain curve ids from
   */
  vertex_ids: Array<string>
}

/**
 * Query the given path.
 */
export type PathGetInfo = {
  /**
   * Which path to query
   */
  path_id: string
}

/**
 * Obtain the sketch target id (if the path was drawn in sketchmode) for a path
 */
export type PathGetSketchTargetUuid = {
  /**
   * Which path to query
   */
  path_id: string
}

/**
 * Obtain vertex ids for a path
 */
export type PathGetVertexUuids = {
  /**
   * Which path to query
   */
  path_id: string
}

/**
 * A segment of a path.
 * Paths are composed of many segments.
 */
export type PathSegment =
  | {
      type: 'line'
      /**
       * End point of the line.
       */
      end: Point3d<LengthUnit>
      /**
       *Whether or not this line is a relative offset
       */
      relative: boolean
    }
  | {
      type: 'arc'
      /**
       * Center of the circle
       */
      center: Point2d<LengthUnit>
      /**
       * Radius of the circle
       */
      radius: LengthUnit
      /**
       * Start of the arc along circle's perimeter.
       */
      start: Angle
      /**
       * End of the arc along circle's perimeter.
       */
      end: Angle
      /**
       *Whether or not this arc is a relative offset
       */
      relative: boolean
    }
  | {
      type: 'bezier'
      /**
       * First control point.
       */
      control1: Point3d<LengthUnit>
      /**
       * Second control point.
       */
      control2: Point3d<LengthUnit>
      /**
       * Final control point.
       */
      end: Point3d<LengthUnit>
      /**
       *Whether or not this bezier is a relative offset
       */
      relative: boolean
    }
  | {
      type: 'tangential_arc'
      /**
       * Radius of the arc.
       * Not to be confused with Raiders of the Lost Ark.
       */
      radius: LengthUnit
      /**
       * Offset of the arc. Negative values will arc clockwise.
       */
      offset: Angle
    }
  | {
      type: 'tangential_arc_to'
      /**
       * Where the arc should end.
       * Must lie in the same plane as the current path pen position.
       * Must not be colinear with current path pen position.
       */
      to: Point3d<LengthUnit>
      /**
       * 0 will be interpreted as none/null.
       */
      angle_snap_increment: Angle | null
    }
  | {
      type: 'arc_to'
      /**
       * Interior point of the arc.
       */
      interior: Point3d<LengthUnit>
      /**
       * End point of the arc.
       */
      end: Point3d<LengthUnit>
      /**
       *Whether or not interior and end are relative to the previous path position
       */
      relative: boolean
    }
  | {
      type: 'circular_involute'
      /**
       *The involute is described between two circles, start_radius is the radius of the inner
       *circle.
       */
      start_radius: LengthUnit
      /**
       *The involute is described between two circles, end_radius is the radius of the outer
       *circle.
       */
      end_radius: LengthUnit
      /**
       *The angle to rotate the involute by. A value of zero will produce a curve with a tangent
       *along the x-axis at the start point of the curve.
       */
      angle: Angle
      /**
       *If reverse is true, the segment will start
       *from the end of the involute, otherwise it will start from that start.
       */
      reverse: boolean
    }
  | {
      type: 'ellipse'
      /**
       * The center point of the ellipse.
       */
      center: Point2d<LengthUnit>
      /**
       * Major axis of the ellipse.
       */
      major_axis: Point2d<LengthUnit>
      /**
       * Minor radius of the ellipse.
       */
      minor_radius: LengthUnit
      /**
       * Start of the path along the perimeter of the ellipse.
       */
      start_angle: Angle
      /**
       * End of the path along the perimeter of the ellipse.
       */
      end_angle: Angle
    }
  | {
      type: 'conic_to'
      /**
       * Interior point that lies on the conic.
       */
      interior: Point2d<LengthUnit>
      /**
       * End point of the conic.
       */
      end: Point2d<LengthUnit>
      /**
       * Tangent at the start of the conic.
       */
      start_tangent: Point2d<LengthUnit>
      /**
       * Tangent at the end of the conic.
       */
      end_tangent: Point2d<LengthUnit>
      /**
       * Whether or not the interior and end points are relative to the previous path position.
       */
      relative: boolean
    }

/**
 * Defines a perspective view.
 */
export type PerspectiveCameraParameters = {
  /**
   * Camera frustum vertical field of view.
   */
  fov_y: number | null
  /**
   * Camera frustum near plane.
   */
  z_near: number | null
  /**
   * Camera frustum far plane.
   */
  z_far: number | null
}

/**
 * Utility method. Performs both a ray cast and projection to plane-local coordinates.
 * Returns the plane coordinates for the given window coordinates.
 */
export type PlaneIntersectAndProject = {
  /**
   * The plane you're intersecting against.
   */
  plane_id: string
  /**
   * Window coordinates where the ray cast should be aimed.
   */
  window: Point2d<number>
}

/**
 * Set the color of a plane.
 */
export type PlaneSetColor = {
  /**
   * Which plane is being changed.
   */
  plane_id: string
  /**
   * What color it should be.
   */
  color: Color
}

/**
 * Options for exporting PLY.
 */
export type PlyExportOptions = {
  /**
   * Co-ordinate system of output data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * Export selection.
   */
  selection: Selection
  /**
   * The storage for the output PLY file.
   */
  storage: PlyStorage
  /**
   * Export length unit.
   *
   * Defaults to millimeters.
   */
  units: UnitLength
}

/**
 * Options for importing PLY.
 */
export type PlyImportOptions = {
  /**
   * Co-ordinate system of input data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * The units of the input data.
   *
   * This is very important for correct scaling and when calculating physics properties like
   * mass, etc.
   *
   * Defaults to millimeters.
   */
  units: UnitLength
}

/**
 * The storage for the output PLY file.
 */
export type PlyStorage = 'ascii' | 'binary_little_endian' | 'binary_big_endian'

/**
 * A point in 2D space
 */
export type Point2d<T = number> = { x: T; y: T }

/**
 * A point in 3D space
 */
export type Point3d<T = number> = { x: T; y: T; z: T }

/**
 * A point in homogeneous (4D) space
 */
export type Point4d<T = number> = { x: T; y: T; z: T; w: T }

/**
 * Project an entity on to a plane.
 */
export type ProjectEntityToPlane = {
  /**
   * Which entity to project (vertex or edge).
   */
  entity_id: string
  /**
   * Which plane to project entity_id onto.
   */
  plane_id: string
  /**
   * If true: the projected points are returned in the plane_id's coordinate system,
   * else: the projected points are returned in the world coordinate system.
   */
  use_plane_coords: boolean
}

/**
 * Project a list of points on to a plane.
 */
export type ProjectPointsToPlane = {
  /**
   * The id of the plane used for the projection.
   */
  plane_id: string
  /**
   * The list of points that will be projected.
   */
  points: Array<Point3d<number>>
  /**
   * If true: the projected points are returned in the plane_id's coordinate sysetm.
   * else: the projected points are returned in the world coordinate system.
   */
  use_plane_coords: boolean
}

/**
 * Reconfigure the stream.
 */
export type ReconfigureStream = {
  /**
   * Width of the stream.
   */
  width: number
  /**
   * Height of the stream.
   */
  height: number
  /**
   * Frames per second.
   */
  fps: number
  /**
   * Video feed's constant bitrate (CBR)
   */
  bitrate: number | null
}

/**
 * What is the given geometry relative to?
 */
export type RelativeTo = 'sketch_plane' | 'trajectory_curve'

/**
 * Remove scene objects.
 */
export type RemoveSceneObjects = {
  /**
   * Objects to remove.
   */
  object_ids: Array<string>
}

/**
 * Command for revolving a solid 2d.
 */
export type Revolve = {
  /**
   * Which sketch to revolve.
   * Must be a closed 2D solid.
   */
  target: ModelingCmdId
  /**
   * The origin of the extrusion axis
   */
  origin: Point3d<LengthUnit>
  /**
   * The axis of the extrusion (taken from the origin)
   */
  axis: Point3d<number>
  /**
   * If true, the axis is interpreted within the 2D space of the solid 2D's plane
   */
  axis_is_2d: boolean
  /**
   * The signed angle of revolution (in degrees, must be <= 360 in either direction)
   */
  angle: Angle
  /**
   * The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
  /**
   * Should the revolution also revolve in the opposite direction along the given axis?
   * If so, this specifies its angle.
   */
  opposite: Opposite<Angle>
}

/**
 * Command for revolving a solid 2d about a brep edge
 */
export type RevolveAboutEdge = {
  /**
   * Which sketch to revolve.
   * Must be a closed 2D solid.
   */
  target: ModelingCmdId
  /**
   * The edge to use as the axis of revolution, must be linear and lie in the plane of the solid
   */
  edge_id: string
  /**
   * The signed angle of revolution (in degrees, must be <= 360 in either direction)
   */
  angle: Angle
  /**
   * The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
  /**
   * Should the revolution also revolve in the opposite direction along the given axis?
   * If so, this specifies its angle.
   */
  opposite: Opposite<Angle>
}

/**
 * A rotation defined by an axis, origin of rotation, and an angle.
 */
export type Rotation = {
  /**
   * Rotation axis.
   * Defaults to (0, 0, 1) (i.e. the Z axis).
   */
  axis: Point3d<number>
  /**
   * Rotate this far about the rotation axis.
   * Defaults to zero (i.e. no rotation).
   */
  angle: Angle
  /**
   * Origin of the rotation. If one isn't provided, the object will rotate about its own bounding box center.
   */
  origin: OriginType
}

/**
 * Removes all of the Objects in the scene
 */
export type SceneClearAll = Record<string, never>

/**
 * The type of scene selection change
 */
export type SceneSelectionType = 'replace' | 'add' | 'remove'

/**
 * The type of scene's active tool
 */
export type SceneToolType =
  | 'camera_revolve'
  | 'select'
  | 'move'
  | 'sketch_line'
  | 'sketch_tangential_arc'
  | 'sketch_curve'
  | 'sketch_curve_mod'

/**
 * Adds one or more entities (by UUID) to the selection.
 */
export type SelectAdd = {
  /**
   * Which entities to select
   */
  entities: Array<string>
}

/**
 * Clear the selection
 */
export type SelectClear = Record<string, never>

/**
 * Find all IDs of selected entities
 */
export type SelectGet = Record<string, never>

/**
 * Removes one or more entities (by UUID) from the selection.
 */
export type SelectRemove = {
  /**
   * Which entities to unselect
   */
  entities: Array<string>
}

/**
 * Replaces current selection with these entities (by UUID).
 */
export type SelectReplace = {
  /**
   * Which entities to select
   */
  entities: Array<string>
}

/**
 * Modifies the selection by simulating a "mouse click" at the given x,y window coordinate
 * Returns ID of whatever was selected.
 */
export type SelectWithPoint = {
  /**
   * Where in the window was selected
   */
  selected_at_window: Point2d<number>
  /**
   * What entity was selected?
   */
  selection_type: SceneSelectionType
}

/**
 * Data item selection.
 */
export type Selection =
  | { type: 'default_scene' }
  | {
      type: 'scene_by_index'
      /**
       * The index.
       */
      index: number
    }
  | {
      type: 'scene_by_name'
      /**
       * The name.
       */
      name: string
    }
  | {
      type: 'mesh_by_index'
      /**
       * The index.
       */
      index: number
    }
  | {
      type: 'mesh_by_name'
      /**
       * The name.
       */
      name: string
    }

/**
 * Send object to front or back.
 */
export type SendObject = {
  /**
   * Which object is being changed.
   */
  object_id: string
  /**
   * Bring to front = true, send to back = false.
   */
  front: boolean
}

/**
 * Set the background color of the scene.
 */
export type SetBackgroundColor = {
  /**
   * The color to set the background to.
   */
  color: Color
}

/**
 * Set the properties of the tool lines for the scene.
 */
export type SetCurrentToolProperties = {
  /**
   * The color to set the tool line to.
   */
  color: Color | null
}

/**
 * Set the default system properties used when a specific property isn't set.
 */
export type SetDefaultSystemProperties = {
  /**
   * The default system color.
   */
  color: Color | null
}

/**
 * Set the grid lines to auto scale. The grid will get larger the further you zoom out,
 * and smaller the more you zoom in.
 */
export type SetGridAutoScale = Record<string, never>

/**
 * Align the grid with a plane or a planar face.
 */
export type SetGridReferencePlane = {
  /**
   * The grid to be moved.
   */
  grid_id: string
  /**
   * The plane or face that the grid will be aligned to.
   * If a face, it must be planar to succeed.
   */
  reference_id: string
}

/**
 * Set the scale of the grid lines in the video feed.
 */
export type SetGridScale = {
  /**
   * Distance between grid lines represents this much distance.
   */
  value: number
  /**
   * Which units the `value` field uses.
   */
  units: UnitLength
}

/**
 *Set the transform of an object.
 */
export type SetObjectTransform = {
  /**
   * Id of the object whose transform is to be set.
   */
  object_id: string
  /**
   * List of transforms to be applied to the object.
   */
  transforms: Array<ComponentTransform>
}

/**
 * Set the units of the scene.
 * For all following commands, the units will be interpreted as the given units.
 * Any previously executed commands will not be affected or have their units changed.
 * They will remain in the units they were originally executed in.
 */
export type SetSceneUnits = {
  /**
   * Which units the scene uses.
   */
  unit: UnitLength
}

/**
 * What kind of entities can be selected?
 */
export type SetSelectionFilter = {
  /**
   * If vector is empty, clear all filters.
   * If vector is non-empty, only the given entity types will be selectable.
   */
  filter: Array<EntityType>
}

/**
 * When you select some entity with the current tool, what should happen to the entity?
 */
export type SetSelectionType = {
  /**
   * What type of selection should occur when you select something?
   */
  selection_type: SceneSelectionType
}

/**
 * Set the current tool.
 */
export type SetTool = {
  /**
   * What tool should be active.
   */
  tool: SceneToolType
}

/**
 * IDs for a side face, extruded from the path of some sketch/2D shape.
 */
export type SideFace = {
  /**
   * ID of the path this face is being extruded from.
   */
  path_id: string
  /**
   * Desired ID for the resulting face.
   */
  face_id: string
}

/**
 * Disable sketch mode.
 * If you are sketching on a face, be sure to not disable sketch mode until you have extruded.
 * Otherwise, your object will not be fused with the face.
 */
export type SketchModeDisable = Record<string, never>

/**
 * Options for importing SolidWorks parts.
 */
export type SldprtImportOptions = {
  /**
   * Splits all closed faces into two open faces.
   *
   * Defaults to `false` but is implicitly `true` when importing into the engine.
   */
  split_closed_faces: boolean
}

/**
 * Add a hole to a Solid2d object before extruding it.
 */
export type Solid2dAddHole = {
  /**
   * Which object to add the hole to.
   */
  object_id: string
  /**
   * The id of the path to use as the inner profile (hole).
   */
  hole_id: string
}

/**
 * Fillets the given edge with the specified radius.
 */
export type Solid3dFilletEdge = {
  /**
   * Which object is being filletted.
   */
  object_id: string
  /**
   * Which edge you want to fillet.
   */
  edge_id: string | null
  /**
   * Which edges you want to fillet.
   */
  edge_ids: Array<string>
  /**
   * The radius of the fillet. Measured in length (using the same units that the current sketch uses). Must be positive (i.e. greater than zero).
   */
  radius: LengthUnit
  /**
   * The maximum acceptable surface gap computed between the filleted surfaces. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
  /**
   * How to apply the cut.
   */
  cut_type: CutType
  /**
   * Which cutting algorithm to use.
   */
  strategy: CutStrategy
  /**
   * What IDs should the resulting faces have?
   * If you've only passed one edge ID, its ID will
   * be the command ID used to send this command, and this
   * field should be empty.
   * If you've passed `n` IDs (to fillet `n` edges), then
   * this should be length `n-1`, and the first edge will use
   * the command ID used to send this command.
   */
  extra_face_ids: Array<string>
}

/**
 * Get a concise description of all of solids edges.
 */
export type Solid3dGetAdjacencyInfo = {
  /**
   * The Solid3d object whose info is being queried.
   */
  object_id: string
  /**
   * Any edge that lies on the extrusion base path.
   */
  edge_id: string
}

/**
 * Gets all faces which use the given edge.
 */
export type Solid3dGetAllEdgeFaces = {
  /**
   * Which object is being queried.
   */
  object_id: string
  /**
   * Which edge you want the faces of.
   */
  edge_id: string
}

/**
 * Gets all edges which are opposite the given edge, across all possible faces.
 */
export type Solid3dGetAllOppositeEdges = {
  /**
   * Which object is being queried.
   */
  object_id: string
  /**
   * Which edge you want the opposites of.
   */
  edge_id: string
  /**
   * If given, only faces parallel to this vector will be considered.
   */
  along_vector: Point3d<number> | null
}

/**
 * Gets the shared edge between these two faces if it exists
 */
export type Solid3dGetCommonEdge = {
  /**
   * Which object is being queried.
   */
  object_id: string
  /**
   * The faces being queried
   */
  face_ids: [string, string]
}

/**
 * Get a concise description of all of an extrusion's faces.
 */
export type Solid3dGetExtrusionFaceInfo = {
  /**
   * The Solid3d object whose extrusion is being queried.
   */
  object_id: string
  /**
   * Any edge that lies on the extrusion base path.
   */
  edge_id: string
}

/**
 * Gets the next adjacent edge for the given edge, along the given face.
 */
export type Solid3dGetNextAdjacentEdge = {
  /**
   * Which object is being queried.
   */
  object_id: string
  /**
   * Which edge you want the opposite of.
   */
  edge_id: string
  /**
   * Which face is used to figure out the opposite edge?
   */
  face_id: string
}

/**
 * Gets the edge opposite the given edge, along the given face.
 */
export type Solid3dGetOppositeEdge = {
  /**
   * Which object is being queried.
   */
  object_id: string
  /**
   * Which edge you want the opposite of.
   */
  edge_id: string
  /**
   * Which face is used to figure out the opposite edge?
   */
  face_id: string
}

/**
 * Gets the previous adjacent edge for the given edge, along the given face.
 */
export type Solid3dGetPrevAdjacentEdge = {
  /**
   * Which object is being queried.
   */
  object_id: string
  /**
   * Which edge you want the opposite of.
   */
  edge_id: string
  /**
   * Which face is used to figure out the opposite edge?
   */
  face_id: string
}

/**
 * Command for shelling a solid3d face
 */
export type Solid3dShellFace = {
  /**
   * Which Solid3D is being shelled.
   */
  object_id: string
  /**
   * Which faces to remove, leaving only the shell.
   */
  face_ids: Array<string>
  /**
   * How thick the shell should be.
   * Smaller values mean a thinner shell.
   */
  shell_thickness: LengthUnit
  /**
   * If true, the Solid3D is made hollow instead of removing the selected faces
   */
  hollow: boolean
}

/**
 * Start a new path.
 */
export type StartPath = Record<string, never>

/**
 * Options for exporting STEP format.
 */
export type StepExportOptions = {
  /**
   * Co-ordinate system of output data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * Timestamp override.
   */
  created: string | null
}

/**
 * Options for importing STEP format.
 */
export type StepImportOptions = {
  /**
   * Splits all closed faces into two open faces.
   *
   * Defaults to `false` but is implicitly `true` when importing into the engine.
   */
  split_closed_faces: boolean
}

/**
 * Options for exporting STL.
 */
export type StlExportOptions = {
  /**
   * Co-ordinate system of output data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * Export selection.
   */
  selection: Selection
  /**
   * Export storage.
   */
  storage: StlStorage
  /**
   * Export length unit.
   *
   * Defaults to millimeters.
   */
  units: UnitLength
}

/**
 * Options for importing STL.
 */
export type StlImportOptions = {
  /**
   * Co-ordinate system of input data.
   *
   * Defaults to the [KittyCAD co-ordinate system].
   *
   * [KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html
   */
  coords: System
  /**
   * The units of the input data.
   *
   * This is very important for correct scaling and when calculating physics properties like
   * mass, etc.
   *
   * Defaults to millimeters.
   */
  units: UnitLength
}

/**
 * Export storage.
 */
export type StlStorage = 'ascii' | 'binary'

/**
 * Get the surface area of entities in the scene or the default scene.
 */
export type SurfaceArea = {
  /**
   * IDs of the entities to get the surface area of. If this is empty, then the default scene is included in
   * the surface area.
   */
  entity_ids: Array<string>
  /**
   * The output unit for the surface area.
   */
  output_unit: UnitArea
}

/**
 * Extrude the object along a path.
 */
export type Sweep = {
  /**
   * Which sketch to sweep.
   * Must be a closed 2D solid.
   */
  target: ModelingCmdId
  /**
   * Path along which to sweep.
   */
  trajectory: ModelingCmdId
  /**
   * If true, the sweep will be broken up into sub-sweeps (extrusions, revolves, sweeps) based on the trajectory path components.
   */
  sectional: boolean
  /**
   * The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero).
   */
  tolerance: LengthUnit
  /**
   * What is this sweep relative to?
   */
  relative_to: RelativeTo
}

/**
 * Co-ordinate system definition.
 *
 * The `up` axis must be orthogonal to the `forward` axis.
 *
 * See [cglearn.eu] for background reading.
 *
 * [cglearn.eu](https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1)
 */
export type System = {
  /**
   * Axis the front face of a model looks along.
   */
  forward: AxisDirectionPair
  /**
   * Axis pointing up and away from a model.
   */
  up: AxisDirectionPair
}

/**
 * Take a snapshot of the current view.
 */
export type TakeSnapshot = {
  /**
   * What image format to return.
   */
  format: ImageFormat
}

/**
 * Ways to transform each solid being replicated in a repeating pattern.
 */
export type Transform = {
  /**
   * Translate the replica this far along each dimension.
   * Defaults to zero vector (i.e. same position as the original).
   */
  translate: Point3d<LengthUnit>
  /**
   * Scale the replica's size along each axis.
   * Defaults to (1, 1, 1) (i.e. the same size as the original).
   */
  scale: Point3d<number>
  /**
   * Rotate the replica about the specified rotation axis and origin.
   * Defaults to no rotation.
   */
  rotation: Rotation
  /**
   * Whether to replicate the original solid in this instance.
   */
  replicate: boolean
}

/**
 * How a property of an object should be transformed.
 */
export type TransformBy<T> = {
  /**
   * The scale, or rotation, or translation.
   */
  property: T
  /**
   * If true, overwrite the previous value with this.
   * If false, the previous value will be modified.
   * E.g. when translating, `set=true` will set a new location,
   * and `set=false` will translate the current location by the given X/Y/Z.
   */
  set: boolean
  /**
   * If true, the transform is applied in local space.
   * If false, the transform is applied in global space.
   */
  is_local: boolean
  /**
   * What to use as the origin for the transformation.
   * If not provided, will fall back to local or global origin, depending on
   * whatever the `is_local` field was set to.
   */
  origin: OriginType | null
}

/**
 * Command for twist extruding a solid 2d.
 */
export type TwistExtrude = {
  /**
   * Which sketch to extrude.
   * Must be a closed 2D solid.
   */
  target: ModelingCmdId
  /**
   * How far off the plane to extrude
   */
  distance: LengthUnit
  /**
   * Which IDs should the new faces have?
   * If this isn't given, the engine will generate IDs.
   */
  faces: ExtrudedFaceInfo | null
  /**
   * Center to twist about (relative to 2D sketch)
   */
  center_2d: Point2d<number>
  /**
   * Total rotation of the section
   */
  total_rotation_angle: Angle
  /**
   *Angle step interval (converted to whole number degrees and bounded between 4° and 90°)
   */
  angle_step_size: Angle
  /**
   *The twisted surface loft tolerance
   */
  tolerance: LengthUnit
}

/**
 * The valid types of angle formats.
 */
export type UnitAngle = 'degrees' | 'radians'

/**
 * The valid types of area units.
 */
export type UnitArea =
  | 'cm2'
  | 'dm2'
  | 'ft2'
  | 'in2'
  | 'km2'
  | 'm2'
  | 'mm2'
  | 'yd2'

/**
 * The valid types for density units.
 */
export type UnitDensity = 'lb:ft3' | 'kg:m3'

/**
 * The valid types of length units.
 */
export type UnitLength = 'cm' | 'ft' | 'in' | 'm' | 'mm' | 'yd'

/**
 * The valid types of mass units.
 */
export type UnitMass = 'g' | 'kg' | 'lb'

/**
 * The valid types of volume units.
 */
export type UnitVolume =
  | 'cm3'
  | 'ft3'
  | 'in3'
  | 'm3'
  | 'yd3'
  | 'usfloz'
  | 'usgal'
  | 'l'
  | 'ml'

/**
 * Update an annotation
 */
export type UpdateAnnotation = {
  /**
   * Which annotation to update
   */
  annotation_id: string
  /**
   * If any of these fields are set, they will overwrite the previous options for the
   * annotation.
   */
  options: AnnotationOptions
}

/**
 * Fit the view to the scene with an isometric view.
 */
export type ViewIsometric = {
  /**
   * How much to pad the view frame by, as a fraction of the object(s) bounding box size.
   * Negative padding will crop the view of the object proportionally.
   * e.g. padding = 0.2 means the view will span 120% of the object(s) bounding box,
   * and padding = -0.2 means the view will span 80% of the object(s) bounding box.
   */
  padding: number
}

/**
 * Get the volume of entities in the scene or the default scene.
 */
export type Volume = {
  /**
   * IDs of the entities to get the volume of. If this is empty, then the default scene is included in
   * the volume.
   */
  entity_ids: Array<string>
  /**
   * The output unit for the volume.
   */
  output_unit: UnitVolume
}

export type WorldCoordinateSystem = 'right_handed_up_z' | 'right_handed_up_y'

/**
 * Fit the view to the specified object(s).
 */
export type ZoomToFit = {
  /**
   * Which objects to fit camera to; if empty, fit to all non-default objects. Defaults to empty vector.
   */
  object_ids: Array<string>
  /**
   * How much to pad the view frame by, as a fraction of the object(s) bounding box size.
   * Negative padding will crop the view of the object proportionally.
   * e.g. padding = 0.2 means the view will span 120% of the object(s) bounding box,
   * and padding = -0.2 means the view will span 80% of the object(s) bounding box.
   */
  padding: number
  /**
   * Whether or not to animate the camera movement.
   */
  animated: boolean
}
