import { isArray } from '@src/lib/utils'

type LogOptions = {
  includeGets?: boolean // default true
  includeSets?: boolean // default true
  includeCalls?: boolean // default true
  shouldLogProp?: (prop: PropertyKey) => boolean // default: skip Symbols & props starting with "_"
  printer?: (...args: any[]) => void // default: console.log
}

/**
 * A class Proxy generated by ChatGPT, which should decorate any class and log
 * any access to it transparently according to the configuration provided.
 */
export function LogAccess(opts: LogOptions = {}) {
  const {
    includeGets = true,
    includeSets = true,
    includeCalls = true,
    shouldLogProp = (prop) => typeof prop === 'string' && !prop.startsWith('_'),
    printer = console.log,
  } = opts

  return <T extends new (...args: any[]) => object>(Base: T): T => {
    return class extends Base {
      constructor(...args: any[]) {
        super(...args)

        // Wrap the created instance (this) in a Proxy and return it from the constructor
        // so any consumer receives the proxied object transparently.
        const target = this

        const handler: ProxyHandler<any> = {
          get(t, prop, receiver) {
            const value = Reflect.get(t, prop, receiver)

            // Only log property "gets" for non-functions (to avoid double-logging when calling methods)
            if (
              includeGets &&
              shouldLogProp(prop) &&
              typeof value !== 'function'
            ) {
              try {
                printer(`[get] ${String(prop)} ->`, value)
              } catch {
                /* never break target behavior if the printer throws */
              }
            }

            // For methods, return a callable proxy that logs on invocation
            if (typeof value === 'function') {
              return new Proxy(value, {
                apply(fn, thisArg, argList) {
                  if (includeCalls && shouldLogProp(prop)) {
                    try {
                      printer(
                        `[call] ${String(prop)}(${argList.map((a) => safePreview(a)).join(', ')})`
                      )
                    } catch {}
                  }
                  return Reflect.apply(fn, thisArg, argList)
                },
              })
            }

            return value
          },

          set(t, prop, newVal, receiver) {
            if (includeSets && shouldLogProp(prop)) {
              try {
                printer(`[set] ${String(prop)} =`, newVal)
              } catch {}
            }
            return Reflect.set(t, prop, newVal, receiver)
          },
        }

        // Returning a Proxy from a constructor is allowed; instanceof still works.
        return new Proxy(target, handler)
      }
    } as unknown as T // TS: we return an instance-compatible shape
  }
}

// Helper: keep previews short & safe for logging
function safePreview(v: unknown): string {
  try {
    if (typeof v === 'string') return JSON.stringify(v)
    if (typeof v === 'number' || typeof v === 'boolean' || v == null)
      return String(v)
    if (typeof v === 'function') return '[Function]'
    if (isArray(v)) return `[Array(${v.length})]`
    if (v instanceof Date) return `Date(${v.toISOString()})`
    return '[Object]'
  } catch {
    return '[Unprintable]'
  }
}
