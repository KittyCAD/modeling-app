import { isDesktop } from '@src/lib/isDesktop'
import { capitaliseFC } from '@src/lib/utils'
import { EnvironmentConfigurationRuntime } from './lib/constants'

function generateDomainsFromBaseDomain(baseDomain: string) {
  return {
    API_URL: `https://api.${baseDomain}`,
    SITE_URL: `https://${baseDomain}`,
    WEBSOCKET_URL: `wss://api.${baseDomain}/ws/modeling/commands`,
    APP_URL: `https://api.${baseDomain}`,
  }
}

export type EnvironmentVariables = {
  readonly NODE_ENV: string | undefined
  readonly VITE_KITTYCAD_BASE_DOMAIN: string | undefined
  readonly VITE_KITTYCAD_API_BASE_URL: string | undefined
  readonly VITE_KITTYCAD_API_WEBSOCKET_URL: string | undefined
  readonly VITE_KITTYCAD_API_TOKEN: string | undefined
  readonly VITE_KITTYCAD_SITE_BASE_URL: string | undefined
  readonly VITE_KITTYCAD_SITE_APP_URL: string | undefined
  readonly POOL: string | undefined
}

/** Store the environment in memory to be accessed during runtime */
let ENVIRONMENT: EnvironmentConfigurationRuntime | null = null

/** Update the runtime environment */
export const updateEnvironment = (environment: string | null) => {
  if (environment === null) {
    ENVIRONMENT = null
  } else {
    if (ENVIRONMENT) {
      ENVIRONMENT.domain = environment
    } else {
      ENVIRONMENT = {
        domain: environment,
        pool: '',
      }
    }
  }
  console.log('updating environment', environment)
}

export const updateEnvironmentPool = (
  environmentName: string,
  pool: string
) => {
  if (!ENVIRONMENT) return
  if (ENVIRONMENT.domain === environmentName) {
    ENVIRONMENT.pool = pool
  }
}

// Do not export the entire Environment! Use env()
const getEnvironmentFromThisFile = () => {
  return ENVIRONMENT
}

/** Get the runtime environment, useful for knowing the key for the environment you are in */
export const getEnvironmentName = () => {
  return ENVIRONMENT?.domain || null
}

/**
 * When you need to display the full environment name within React
 */
export const getEnvironmentNameForDisplay = (env: EnvironmentVariables) => {
  return env.NODE_ENV === 'development'
    ? '.env'
    : capitaliseFC(getEnvironmentName() || '')
}

/**
 * When you need to display the shorthand for the environment name
 * Prod, Dev, etc...
 */
export const getShorthandEnvironmentNameForDisplay = (
  env: EnvironmentVariables
) => {
  if (env.NODE_ENV === 'development') {
    return '.env'
  }
  const shorthand = getEnvironmentFromThisFile()?.shorthand
  return shorthand ? capitaliseFC(shorthand) : ''
}

export const viteEnv = () => {
  // It turns out import.meta.env is a really fucky env var passing method.
  // It's purely generated by Vite and nothing else.
  // For Jest tests, we use babel to deal with it (it's a Syntax error otherwise)
  // @ts-ignore: TS1343
  return import.meta.env
}

export const windowElectronProcessEnv = () => {
  return typeof window !== 'undefined' && typeof window.electron !== 'undefined'
    ? window?.electron?.process?.env
    : undefined
}

export const processEnv = () => {
  if (typeof process === 'undefined') {
    // Web, no window.process or process
    return undefined
  }
  return process.env
}

/**
 * This function will work in any runtime. Note that we shouldn't be using this for any values outside of the
 * EnvironmentVariables type. This is not going to replace process.env.
 *
 * Vite -> node.js -> bridge -> javascript
 * We want to have the node.js and javascript runtime share the same code for getting these important configurations.
 */
export default (): EnvironmentVariables => {
  // Compute the possible environment variables, order operation is important
  // runtime (TODO) > process.env > window.electron.process.env > import.meta.env
  const viteOnly = viteEnv()
  const windowElectronProcessEnvOnly = windowElectronProcessEnv()
  const processEnvOnly = processEnv()
  const env = processEnvOnly || windowElectronProcessEnvOnly || viteOnly

  let { API_URL, SITE_URL, WEBSOCKET_URL, APP_URL } =
    generateDomainsFromBaseDomain(env.VITE_KITTYCAD_BASE_DOMAIN)
  let pool = ''

  /**
   * If you are desktop, see if you have any runtime environment which can be read from disk and
   * populated during the sign in workflow.
   * A built binary will allow the user to sign into different environments on the desktop
   */
  const environment = getEnvironmentFromThisFile()
  if (isDesktop() && environment) {
    let { API_URL, SITE_URL, WEBSOCKET_URL, APP_URL } =
      generateDomainsFromBaseDomain(environment.domain)
    pool = environment && environment.pool ? environment.pool : ''
  }

  const environmentVariables: EnvironmentVariables = {
    NODE_ENV: (env.NODE_ENV as string) || viteOnly.MODE || undefined,
    VITE_KITTYCAD_BASE_DOMAIN: (env.VITE_KITTYCAD_BASE_DOMAIN as string) || undefined,
    VITE_KITTYCAD_API_BASE_URL: (API_URL as string) || undefined,
    VITE_KITTYCAD_API_WEBSOCKET_URL: (WEBSOCKET_URL as string) || undefined,
    VITE_KITTYCAD_API_TOKEN:
      (env.VITE_KITTYCAD_API_TOKEN as string) || undefined,
    VITE_KITTYCAD_SITE_BASE_URL: (SITE_URL as string) || undefined,
    VITE_KITTYCAD_SITE_APP_URL: (APP_URL as string) || undefined,
    POOL: pool,
  }

  return environmentVariables
}
