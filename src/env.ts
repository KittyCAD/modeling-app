import type { Environment, EnvironmentName } from '@src/lib/constants'
import { SUPPORTED_ENVIRONMENTS } from '@src/lib/constants'
import { isDesktop } from '@src/lib/isDesktop'

type EnvironmentVariableSources = {
  readonly VITE_KITTYCAD_API_BASE_URL: string | undefined
  readonly VITE_KITTYCAD_API_WEBSOCKET_URL: string | undefined
  readonly VITE_KITTYCAD_SITE_BASE_URL: string | undefined
}

type EnvironmentVariables = {
  readonly NODE_ENV: string | undefined
  readonly VITE_KITTYCAD_API_BASE_URL: string | undefined
  readonly VITE_KITTYCAD_API_WEBSOCKET_URL: string | undefined
  readonly VITE_KITTYCAD_API_TOKEN: string | undefined
  readonly VITE_KITTYCAD_SITE_BASE_URL: string | undefined
  readonly VITE_KITTYCAD_SITE_APP_URL: string | undefined
  readonly PROD: string | undefined
  readonly TEST: string | undefined
  readonly DEV: string | undefined
  readonly CI: string | undefined
  readonly SOURCES: EnvironmentVariableSources
}

/** Store the environment in memory to be accessed during runtime */
let ENVIRONMENT: Environment | null = null

/** Update the runtime environment */
export const updateEnvironment = (environment: EnvironmentName) => {
  ENVIRONMENT = SUPPORTED_ENVIRONMENTS[environment]
  console.log('updating environment', environment)
}

// Do not export the entire Environment! Use env()
const getEnvironmentFromThisFile = () => {
  return ENVIRONMENT
}

/** Get the runtime environment */
export const getEnvironmentName = () => {
  return ENVIRONMENT?.name || null
}

export const viteEnv = () => {
  // It turns out import.meta.env is a really fucky env var passing method.
  // It's purely generated by Vite and nothing else.
  // For Jest tests, we use babel to deal with it (it's a Syntax error otherwise)
  // @ts-ignore: TS1343
  return import.meta.env
}

export const windowElectronProcessEnv = () => {
  return typeof window !== 'undefined' && typeof window.electron !== 'undefined'
    ? window?.electron?.process?.env
    : undefined
}

export const processEnv = () => {
  if (typeof process === 'undefined') {
    // Web, no window.process or process
    return undefined
  } else if (
    typeof process !== 'undefined' &&
    typeof window !== 'undefined' &&
    process.env.TEST !== 'true'
  ) {
    // Web, you made window.process, why :(, need process.env.TEST to make sure the frontend gets evaluated.
    // The frontend can spoof this too :(
    return undefined
  }

  return process.env
}

/**
 * This function will work in any runtime. Note that we shouldn't be using this for any values outside of the
 * EnvironmentVariables type. This is not going to replace process.env.
 *
 * Vite -> node.js -> bridge -> javascript
 * We want to have the node.js and javascript runtime share the same code for getting these important configurations.
 */
export default (): EnvironmentVariables => {
  // Compute the possible environment variables, order operation is important
  // runtime (TODO) > process.env > window.electron.process.env > import.meta.env

  const viteOnly = viteEnv()
  const windowElectronProcessEnvOnly = windowElectronProcessEnv()
  const processEnvOnly = processEnv()
  const env = processEnvOnly || windowElectronProcessEnvOnly || viteOnly
  // Vite uses Booleans and process.env uses strings
  let PROD = env.PROD
  if (typeof PROD === 'boolean') {
    PROD = Number(PROD).toString()
  }
  let DEV = env.DEV
  if (typeof DEV === 'boolean') {
    DEV = Number(DEV).toString()
  }

  /**
   * Resolve the API, Site, and Websocket URL
   * This is computed during runtime for Desktop.
   * Web will have hard coded values from the VITE .env
   * electron will get this from the sign in page and the local disk cache
   *
   *
   * catch 22: If you are in the sign in page and there are URLs, they should
   * point to the VITE .env file for that build
   *
   * e.g. View this sample -> button would be pointing to production if built with the production .env
   */
  let API_URL = env.VITE_KITTYCAD_API_BASE_URL
  let SITE_URL = env.VITE_KITTYCAD_SITE_BASE_URL
  let WEBSOCKET_URL = env.VITE_KITTYCAD_API_WEBSOCKET_URL

  const viteSource = '.env.development(.local)'
  const supportedEnvironmentSource = 'Supported Environment configuration'
  /**
   * Initialize sources
   * TODO: If you package for development environment it will read .env instead of vite from packaged binary?
   */
  let sources: EnvironmentVariableSources = {
    VITE_KITTYCAD_API_BASE_URL: viteSource,
    VITE_KITTYCAD_SITE_BASE_URL: viteSource,
    VITE_KITTYCAD_API_WEBSOCKET_URL: viteSource,
  }

  /**
   * If you are desktop, see if you have any runtime environment which can be read from disk and
   * populated during the sign in workflow.
   * A built binary will allow the user to sign into different environments on the desktop
   */
  const environment = getEnvironmentFromThisFile()
  if (env.NODE_ENV === 'production' && isDesktop() && environment) {
    API_URL = environment.API_URL
    SITE_URL = environment.SITE_URL
    WEBSOCKET_URL = environment.WEBSOCKET_URL

    sources = {
      VITE_KITTYCAD_API_BASE_URL: supportedEnvironmentSource,
      VITE_KITTYCAD_SITE_BASE_URL: supportedEnvironmentSource,
      VITE_KITTYCAD_API_WEBSOCKET_URL: supportedEnvironmentSource,
    }
  }

  const environmentVariables: EnvironmentVariables = {
    NODE_ENV: (env.NODE_ENV as string) || undefined,
    VITE_KITTYCAD_API_BASE_URL: (API_URL as string) || undefined,
    VITE_KITTYCAD_API_WEBSOCKET_URL: (WEBSOCKET_URL as string) || undefined,
    VITE_KITTYCAD_API_TOKEN:
      (env.VITE_KITTYCAD_API_TOKEN as string) || undefined,
    VITE_KITTYCAD_SITE_BASE_URL: (SITE_URL as string) || undefined,
    VITE_KITTYCAD_SITE_APP_URL:
      (env.VITE_KITTYCAD_SITE_APP_URL as string) || undefined,
    PROD: PROD || undefined,
    TEST: (env.TEST as string) || undefined,
    DEV: DEV || undefined,
    CI: (env.CI as string) || undefined,
    SOURCES: sources,
  }

  return environmentVariables
}
